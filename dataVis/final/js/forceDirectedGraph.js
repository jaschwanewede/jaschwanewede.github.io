class ForceDirectedGraph {

    /**
     * Class constructor with basic chart configuration
     * @param {Object}
     * @param {Array}
     */
    constructor(_config, _data) {
        this.config = {
          parentElement: _config.parentElement,
          containerWidth: window.innerWidth,
          containerHeight: window.innerHeight * 0.8,
          margin: {top: 25, right: 20, bottom: 20, left: 35},
          tooltipPadding: 10
        }
        this.data = _data;
        this.initVis();
        this.selectedNode = null;
      }

      initVis(){
        let vis = this;
  
        vis.config.width = vis.config.containerWidth - vis.config.margin.left - vis.config.margin.right;
        vis.config.height = vis.config.containerHeight - vis.config.margin.top - vis.config.margin.bottom;
    
        const adjustedWidth = vis.config.width > 500 ? vis.config.width - 500 : vis.config.width;

        vis.svg = d3.select(vis.config.parentElement).append('svg')
          .attr('width', adjustedWidth)
          .attr('height', vis.config.containerHeight);

        vis.chart = vis.svg.append('g')
          .attr('transform', `translate(${vis.config.margin.left},${vis.config.margin.top})`);
        
        vis.simulation = d3.forceSimulation()
          .force('link', d3.forceLink()
            .id(d => d.id)
            .distance(100)
            .strength(0.04))
          .force('charge', d3.forceManyBody())
          .force('center', d3.forceCenter((vis.config.width - 500) / 2, vis.config.height / 2));
      
        //ChatGPT assisted, helping with clicking off node by clicking svg
        vis.svg.on('click', function(event) {
          if (event.target.tagName === 'svg') {
            
            d3.select('#tooltip').style('display', 'none');

            vis.chart.selectAll('circle').style('opacity', 1).classed('active', false);
            vis.chart.selectAll('line').style('opacity', 1);


            const dropdown = d3.select("#neighbors");
            dropdown.selectAll('option').remove();

            const current = d3.select("#current");
            current.selectAll('option').remove();

            current.append('option')
              .text("None");
          }
          this.createLegend();
        });
        //end of ChatGPT
        
        vis.updateVis();
      }

      updateVis() {
        let vis = this;
    
        vis.simulation.nodes(vis.data.nodes);
        vis.simulation.force('link').links(vis.data.links);
        
        //Code below Generated by ChatGPT, helping with coding the neighbor nodes
        vis.data.nodes.forEach(node => node.neighbors = []);
        vis.data.links.forEach(link => {
          const source = typeof link.source === "object" ? link.source : vis.data.nodes.find(n => n.id === link.source);
          const target = typeof link.target === "object" ? link.target : vis.data.nodes.find(n => n.id === link.target);
          source.neighbors.push(target);
          target.neighbors.push(source);
        });
        //end of ChatGPT

        vis.renderVis();
        this.createLegend();
  
        console.log('Nodes:', vis.data.nodes); //DEBUGGING
        console.log('Links:', vis.data.links);
      }
    
      renderVis() {
        let vis = this;
      
        const links = vis.chart.selectAll('line')
          .data(vis.data.links, d => `${d.source}-${d.target}`) // Unique string key
          .join('line')
          .attr('stroke', d => 
            d.type === "Z" ? '#fc8d59' : 
            d.type === "Y" ? "#91bfdb" : "#ddd");
      
        const nodes = vis.chart.selectAll('circle')
          .data(vis.data.nodes, d => d.id)
          .join('circle')
          .attr('r', d => 3 * Math.log10(d.size) + 4)
          .attr("fill", d =>
            d.id === "Super Smash Bros. Ultimate" ? "#404040" :
            d.party === "Y" ? "#d73027" :
            "#4575b4" 
          )

          .attr('tabindex', '0')
          .call(d3.drag() //DRAG CALL
            .on("start", dragstarted)
            .on("drag", dragged)
            .on("end", dragended));
      
        nodes
          .on('mouseover', (event, d) => showTooltip(event, d)) //shows tooltip when mouseover
          .on('mouseout', hideTooltip) //hides tooltip 

          .on('focus', function(event, d) { //shows tooltip if enter is tabbed (accesibility)
              const node = this.getBoundingClientRect();

              //part below assisted by ChatGPT
              const fakeEvent = {
                pageX: node.left + window.scrollX + node.width / 2,
                pageY: node.top + window.scrollY + node.height / 2
              };//end of assistance 

              showTooltip(fakeEvent, d)
          })

          .on('blur', (event, d) => hideTooltip) //hides tooltip when tabbed off
          
          .on('keydown', function(event, d) { //shows neighbors if enter is pressed (accesibility)
            if (event.key === "Enter") {
              
              showTooltip(event, d)
              highlightNeighbors(event, d)
              event.stopPropagation(); // Prevent event from bubbling up to SVG
            }

            if (event.key === "Backspace") {
    
              resetSelect();

            }
          })
          
          .on('click', (event, clickedNode) => {
            showTooltip(event, clickedNode)
            highlightNeighbors(event, clickedNode);
            event.stopPropagation(); // Prevent event from bubbling up to SVG
            
          });

          //using the dropdowns to search for nodes/call events
          const orderDropdown = d3.select("#order")
          const neighborDropdown = d3.select("#neighbors");
          

          //order Dropdown searching
          orderDropdown
            .on("click", function(event, clickedNode) {
              const selectedId = d3.select(this).property("value");

              const selectedNode = vis.data.nodes.find(d => d.id === selectedId);

              //chatGPT assisted
              const circle = vis.chart.selectAll('circle')
                .filter(d => d.id === selectedId)
                .node();

              const location = circle.getBoundingClientRect();
              //end of assistance 

              const fakeEvent = {
                pageX: location.left + window.scrollX + location.width / 2,
                pageY: location.top + window.scrollY + location.height / 2
              };

              showTooltip(fakeEvent, selectedNode)
              highlightNeighbors(null, selectedNode);
              
            })
            
            .on('keydown', function(event, d) { 
              if (event.key === "Enter") {
                const selectedId = d3.select(this).property("value");

                const selectedNode = vis.data.nodes.find(d => d.id === selectedId);

                //chatGPT assisted
                const circle = vis.chart.selectAll('circle')
                  .filter(d => d.id === selectedId)
                  .node();

                const location = circle.getBoundingClientRect();
                //end of assistance 

                const fakeEvent = {
                  pageX: location.left + window.scrollX + location.width / 2,
                  pageY: location.top + window.scrollY + location.height / 2
                };

                showTooltip(fakeEvent, selectedNode)
                highlightNeighbors(null, selectedNode);
              }

              if (event.key === "Backspace") {
                resetSelect();
              }
            })
            
            .on('change', function(event, d){
              const selectedId = d3.select(this).property("value");

              const selectedNode = vis.data.nodes.find(d => d.id === selectedId);
              
              //chatGPT assisted
              const circle = vis.chart.selectAll('circle')
                .filter(d => d.id === selectedId)
                .node();

              const location = circle.getBoundingClientRect();
              //end of assistance 

              const fakeEvent = {
                pageX: location.left + window.scrollX + location.width / 2,
                pageY: location.top + window.scrollY + location.height / 2
              };

              showTooltip(fakeEvent, selectedNode);
            });
            

          //neighbor Dropdown searching
          neighborDropdown
            .on("click", function(event, clickedNode) {
              const selectedId = d3.select(this).property("value");

              const selectedNode = vis.data.nodes.find(d => d.id === selectedId);

              //chatGPT assisted
              const circle = vis.chart.selectAll('circle')
                .filter(d => d.id === selectedId)
                .node();

              const location = circle.getBoundingClientRect();
              //end of assistance 

              const fakeEvent = {
                pageX: location.left + window.scrollX + location.width / 2,
                pageY: location.top + window.scrollY + location.height / 2
              };

              showTooltip(fakeEvent, selectedNode)
              highlightNeighbors(null, selectedNode);
              
            })
            
            .on('keydown', function(event, d) { 
              if (event.key === "Enter") {
                const selectedId = d3.select(this).property("value");

                const selectedNode = vis.data.nodes.find(d => d.id === selectedId);

                //chatGPT assisted
                const circle = vis.chart.selectAll('circle')
                  .filter(d => d.id === selectedId)
                  .node();

                const location = circle.getBoundingClientRect();
                //end of assistance 

                const fakeEvent = {
                  pageX: location.left + window.scrollX + location.width / 2,
                  pageY: location.top + window.scrollY + location.height / 2
                };

                showTooltip(fakeEvent, selectedNode)
                highlightNeighbors(null, selectedNode);
              }

              if (event.key === "Backspace") {
                resetSelect();
              }
            })
            
            .on('change', function(event, d){
              const selectedId = d3.select(this).property("value");

              const selectedNode = vis.data.nodes.find(d => d.id === selectedId);
              
              //chatGPT assisted
              const circle = vis.chart.selectAll('circle')
                .filter(d => d.id === selectedId)
                .node();

              const location = circle.getBoundingClientRect();
              //end of assistance 

              const fakeEvent = {
                pageX: location.left + window.scrollX + location.width / 2,
                pageY: location.top + window.scrollY + location.height / 2
              };

              showTooltip(fakeEvent, selectedNode);
            });

          const nodeFilter = d3.select("#filteredNode")
          
          nodeFilter
            .on('change', function(){
              filterNodes();
            });

          function filterNodes() {
            var filter = document.getElementById("filteredNode");
	          var selectedFilter = filter.options[filter.selectedIndex].value;  

              if (selectedFilter === 'all') {
                vis.chart.selectAll('circle')

                  .style('opacity', 1); //reset, all present

              } else if (selectedFilter === 'nintendo'){
               
                vis.chart.selectAll('circle')
                  .style('opacity', d => d.party === "Y" ? 1 : 0.1);

              } else if (selectedFilter === '3rd') {

                vis.chart.selectAll('circle')
                  .style('opacity', d => d.party === "N" ? 1 : 0.1);
              }
          }

          const linkFilter = d3.select("#filteredLink")
          
          linkFilter
            .on('change', function(){
              filterLinks();
            });

          function filterLinks() {
            var filter = document.getElementById("filteredLink");
	          var selectedFilter = filter.options[filter.selectedIndex].value;  

              if (selectedFilter === 'all') {
                vis.chart.selectAll('line')
                  .style('opacity', 1); //reset, all present

              } else if (selectedFilter === 'fighter'){
               
                vis.chart.selectAll('line')
                  .style('opacity', d => d.type === "Z" ? 1 : 0.1);

              } else if (selectedFilter === 'other') {

                vis.chart.selectAll('line')
                  .style('opacity', d => d.type === "Y" ? 1 : 0.1);

              } else if (selectedFilter === 'non-smash') {

                vis.chart.selectAll('line')
                  .style('opacity', d => d.type === "X" ? 1 : 0.1);
              }
          }


          //ChatGPT assisted
          function highlightNeighbors(event, clickedNode) {
            if (vis.selectedNode === clickedNode) { // if repeat node
              vis.selectedNode = null;
              resetSelect();
            } else {
              vis.selectedNode = clickedNode; // set new node
              const neighbors = new Set(clickedNode.neighbors.map(d => d.id));
              neighbors.add(clickedNode.id); // Include clicked node itself
            
              const sortedNeighbors = clickedNode.neighbors
                .sort((a, b) => b.size - a.size);

              const dropdown = d3.select("#neighbors");
              dropdown.selectAll('option').remove();

              const current = d3.select("#current");
              current.selectAll('option').remove();

              current.append('option')
                .text(`${clickedNode.id}`);

              sortedNeighbors.forEach(neighbor => {
              dropdown.append('option')
                .attr('value', neighbor.id)
                .text(`${neighbor.id}: ${neighbor.size}M copies sold`);
              });

              nodes
                .style('opacity', d => neighbors.has(d.id) ? 1 : 0.1)
                .classed('active', d => d.id === clickedNode.id);
          
              links
                .style('opacity', l => {
                  const sourceId = typeof l.source === "object" ? l.source.id : l.source;
                  const targetId = typeof l.target === "object" ? l.target.id : l.target;
                  return (sourceId === clickedNode.id || targetId === clickedNode.id) ? 1 : 0.1;
                 });
              }
          }
          //end of ChatGPT assistance

          function resetSelect() {
            hideTooltip();
            nodes
              .style('opacity', 1)
              .classed('active', false);
          
            links
              .style('opacity', 1);

            const dropdown = d3.select("#neighbors");
            dropdown.selectAll('option').remove();

            const current = d3.select("#current");
            current.selectAll('option').remove();

            current.append('option')
              .text("None");
          
          }
      
        vis.simulation.on('tick', () => {
          links
            .attr('x1', d => d.source.x)
            .attr('y1', d => d.source.y)
            .attr('x2', d => d.target.x)
            .attr('y2', d => d.target.y);
      
          nodes
            .attr('cx', d => d.x)
            .attr('cy', d => d.y)
        });
      
        function dragstarted(event, d) {
          if (!event.active) vis.simulation.alphaTarget(0.3).restart();
          d.fx = d.x;
          d.fy = d.y;
        }
      
        function dragged(event, d) {
          d.fx = event.x;
          d.fy = event.y;
        }
      
        function dragended(event, d) {
          if (!event.active) vis.simulation.alphaTarget(0);
          d.fx = null;
          d.fy = null;

        }

        function showTooltip(event, d) {

          //reset other strokes
          vis.chart.selectAll('circle')
            .attr('stroke', null)
            .attr('stroke-width', null);

          //add slight stroke to make node more visible
          vis.chart.selectAll('circle')
            .filter(game => game.id === d.id)
            .attr('stroke', 'black')
            .attr('stroke-width', 2);

          d3.select('#tooltip')
            .style('display', 'block')
            .style('left', (event.pageX + vis.config.tooltipPadding) + 'px')
            .style('top', (event.pageY + vis.config.tooltipPadding) + 'px')
            .html(`
              <div class="tooltip-title"><strong>Franchise: </strong>${d.id}</div>
              <div><i>Estimated Copies Sold (Millions): </i>${d.size}</div>
              <div><i>Main Genre: </i>${d.genre}</div>
              <div><i>Number of Crossovers: </i>${d.neighborCount}</div>
            `);
        }

        function hideTooltip() {
          d3.select('#tooltip').style('display', 'none');

          //reset all strokes
          vis.chart.selectAll('circle')
            .attr('stroke', null)
            .attr('stroke-width', null);
        }

       function createLegend() {
          console.log("Debug check");
          const legend = d3.select('#legend');

          const svg = legend.append('svg')
            .attr('width', 400)
            .attr('height', 160);

          const parties = [
          { label: 'Nintendo Franchise', color: 'red' },
          { label: 'Third-Party Franchise', color: 'blue' }
          ];

          const links = [
          { label: 'Fighter in Smash', color: 'pink' },
          { label: 'Other Smash Crossover', color: 'green' },
          { label: 'Franchise Crossover', color: 'gray' }
          ];

          svg.append('text')
            .text('Node Color:')
            .attr('font-weight', 'bold');

          parties.forEach((item, i) => {
          svg.append('circle')
            .attr('cx', 20)
            .attr('cy', 40 + i * 25)
            .attr('r', 10)
            .attr('fill', item.color);

          svg.append('text')
            .attr('x', 40)
            .attr('y', 45 + i * 25)
            .text(item.label);
          });

          svg.append('text')
            .attr('x', 10)
            .attr('y', 100)
            .text('Edge Color:')
            .attr('font-weight', 'bold');

          links.forEach((item, i) => {
          svg.append('line')
            .attr('x1', 20)
            .attr('y1', 115 + i * 20)
            .attr('x2', 50)
            .attr('y2', 115 + i * 20)
            .attr('stroke', item.color)
            .attr('stroke-width', 3);

          svg.append('text')
            .attr('x', 60)
            .attr('y', 120 + i * 20)
            .text(item.label);
        });
      }

      dataManipulation(); 
      dataFiltering();

      }

}